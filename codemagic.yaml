workflows:
  ios-workflow:
    name: iOS Workflow - Clean Start
    max_build_duration: 120
    instance_type: mac_mini_m1
    environment:
      vars:
        APP_ID: app.randomaita.final
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        BUNDLE_ID: app.randomaita.final
        TEAM_ID: US86BZ3GH5
      groups:
        - ios_signing  # iOS certificate and profile secrets (CERT_P12_BASE64, P12_PASSWORD, MOBILEPROVISION_BASE64, PROFILE_NAME)
    scripts:
      - name: Install Node.js dependencies
        script: |
          npm ci
      
      - name: Sync Capacitor
        script: |
          npx cap sync ios
      
      - name: Clear DerivedData
        script: |
          rm -rf ~/Library/Developer/Xcode/DerivedData/*
      
      - name: Install Certificate and Provisioning Profile
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          : "${CERT_P12_BASE64:?missing CERT_P12_BASE64}"
          : "${MOBILEPROVISION_BASE64:?missing MOBILEPROVISION_BASE64}"
          # Optional: PROFILE_NAME; Required now: P12_PASSWORD (non-empty)
          
          KEYCHAIN=build.keychain
          
          b64_decode() { if base64 --help >/dev/null 2>&1; then base64 --decode; else base64 -D; fi; }
          strip_wrap_quotes() { sed 's/^"//; s/"$//'; }
          trim_pw() { tr -d '\r' | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//'; }
          
          # Normalize password
          P12_PASSWORD_RAW="${P12_PASSWORD-}"
          P12_PASSWORD_CLEAN="$(printf %s "$P12_PASSWORD_RAW" | strip_wrap_quotes | trim_pw)"
          if [ -z "$P12_PASSWORD_CLEAN" ]; then
            echo "ERROR: P12_PASSWORD is required for this certificate."
            exit 1
          fi
          
          # Keychain
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 7200 "$KEYCHAIN"
          
          # Decode inputs
          printf %s "$CERT_P12_BASE64"        | strip_wrap_quotes | b64_decode > /tmp/cert.p12
          printf %s "$MOBILEPROVISION_BASE64" | strip_wrap_quotes | b64_decode > /tmp/profile.mobileprovision
          
          # Hard hash assertion to prevent stale secrets
          EXPECTED_P12_SHA256="a301c8c8988c2c2cbc2ef72ab2cfb96b4e5deae6ae37725b0176dcb086b158f2"
          ACTUAL_SHA256="$(shasum -a 256 /tmp/cert.p12 2>/dev/null | awk '{print $1}' || echo unknown)"
          
          echo "=== Certificate Debug Info ==="
          echo "P12 file size: $(stat -f%z /tmp/cert.p12 2>/dev/null || stat -c%s /tmp/cert.p12 2>/dev/null || wc -c < /tmp/cert.p12) bytes"
          echo "ASSERT p12 SHA256: $ACTUAL_SHA256"
          echo "P12_PASSWORD length: ${#P12_PASSWORD_CLEAN}"
          
          # Case-insensitive comparison (convert both to lowercase)
          if [ "$(echo "$ACTUAL_SHA256" | tr '[:upper:]' '[:lower:]')" != "$(echo "$EXPECTED_P12_SHA256" | tr '[:upper:]' '[:lower:]')" ]; then
            echo "ERROR: Codemagic is not using the expected certificate. Update CERT_P12_BASE64."
            echo "Expected: $EXPECTED_P12_SHA256"
            echo "Actual:   $ACTUAL_SHA256"
            exit 1
          fi
          
          # Pre-verify with OpenSSL using the SAME password
          if ! openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD_CLEAN}" -nokeys -info >/dev/null 2>&1 \
             && ! openssl pkcs12 -legacy -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD_CLEAN}" -nokeys -info >/dev/null 2>&1; then
            echo "ERROR: OpenSSL cannot open p12 with the provided password (wrong password or corrupt p12)."
            exit 1
          fi
          echo "OpenSSL check: p12 verified WITH password."
          
          # Import (WITH password)
          echo "Import path: WITH password"
          security import /tmp/cert.p12 -k "$KEYCHAIN" -f pkcs12 -P "$P12_PASSWORD_CLEAN" \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          
          # Allow tools to access the key non-interactively
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"
          
          # Install provisioning profile
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROFILE_PLIST=$(/usr/bin/security cms -D -i /tmp/profile.mobileprovision)
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST")
          PROFILE_NAME_SAFE=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST")
          : "${PROFILE_UUID:?Failed to parse profile UUID}"
          cp /tmp/profile.mobileprovision "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision"
          
          # === BEGIN: Provisioning profile facts (export for later steps) ===
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST")
          TEAM_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          APP_ID_FULL=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          
          # Derive bundle id from application-identifier (TEAMID.bundleid)
          BUNDLE_ID="${APP_ID_FULL#${TEAM_ID}.}"
          
          echo "Profile Name: $PROFILE_NAME"
          echo "Profile UUID: $PROFILE_UUID"
          echo "Team ID     : $TEAM_ID"
          echo "App ID Full : $APP_ID_FULL"
          echo "Bundle ID   : $BUNDLE_ID"
          
          # Export to Codemagic env for subsequent steps
          echo "PROFILE_UUID=$PROFILE_UUID" >> "$CM_ENV"
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$CM_ENV"
          echo "TEAM_ID=$TEAM_ID"           >> "$CM_ENV"
          echo "BUNDLE_ID=$BUNDLE_ID"       >> "$CM_ENV"
          # === END: Provisioning profile facts ===
          
          echo "${PROFILE_NAME:-${PROFILE_NAME_SAFE:-}}" > /tmp/profile_name.txt
          echo "$PROFILE_UUID" > /tmp/profile_uuid.txt
          
          echo "✓ Certificate imported and profile installed ($PROFILE_UUID)"
      
      - name: Clean Pods Deterministically
        script: |
          set -euo pipefail
          cd ios/App
          pod repo update
          pod deintegrate || true
          rm -rf Pods Podfile.lock
          pod install --repo-update
          cd ../..
      
      - name: Verify Signing Configuration
        script: |
          set -euo pipefail
          cd ios/App
          
          echo "=== App target (Release) ==="
          xcodebuild -showBuildSettings -workspace App.xcworkspace -scheme App -configuration Release 2>/dev/null \
           | grep -E "PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|PROVISIONING_PROFILE_SPECIFIER" | sed 's/^[[:space:]]*//'
          
          echo ""
          echo "=== Pods-App target (Release) — expect CODE_SIGNING_ALLOWED = NO ==="
          xcodebuild -showBuildSettings -project Pods/Pods.xcodeproj -target Pods-App -configuration Release 2>/dev/null \
           | grep -E "CODE_SIGNING_ALLOWED|CODE_SIGN_STYLE|PROVISIONING_PROFILE" | sed 's/^[[:space:]]*//' || echo "Pods-App target not found (this is OK if pods not installed yet)"
          
          cd ../..
      
      - name: Build Archive
        script: |
          set -euo pipefail
          cd ios/App
          
          : "${TEAM_ID:?TEAM_ID is not set}"
          : "${BUNDLE_ID:?BUNDLE_ID is not set}"
          : "${PROFILE_UUID:?PROFILE_UUID is not set}"
          
          KEYCHAIN=build.keychain
          
          echo "Using Team: $TEAM_ID"
          echo "Using Bundle ID: $BUNDLE_ID"
          echo "Using Profile UUID: $PROFILE_UUID"
          
          ARCHIVE_PATH="$HOME/Library/Developer/Xcode/Archives/$(date +%Y-%m-%d)/App-$(date +%H%M).xcarchive"
          mkdir -p "$(dirname "$ARCHIVE_PATH")"
          
          if command -v xcpretty >/dev/null 2>&1; then
            xcodebuild -workspace App.xcworkspace \
              -scheme App \
              -configuration Release \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              CODE_SIGN_STYLE=Manual \
              DEVELOPMENT_TEAM="$TEAM_ID" \
              PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              PROVISIONING_PROFILE_SPECIFIER= \
              OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN" \
              archive 2>&1 | xcpretty && exit ${PIPESTATUS[0]} || {
              echo ""
              echo "=== ARCHIVE BUILD FAILED ==="
              exit 1
            }
          else
            xcodebuild -workspace App.xcworkspace \
              -scheme App \
              -configuration Release \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              CODE_SIGN_STYLE=Manual \
              DEVELOPMENT_TEAM="$TEAM_ID" \
              PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              PROVISIONING_PROFILE_SPECIFIER= \
              OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN" \
              archive 2>&1 | tee /tmp/archive_build.log || {
              echo ""
              echo "=== ARCHIVE BUILD FAILED ==="
              echo ""
              echo "Error details from build log:"
              tail -50 /tmp/archive_build.log
              echo ""
              exit 1
            }
          fi
          
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "ERROR: Archive was not created at $ARCHIVE_PATH"
            exit 1
          fi
          
          echo "✓ Archive created successfully at $ARCHIVE_PATH"
          cd ../..
      
      - name: Verify Archive Signing
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          : "${TEAM_ID:?TEAM_ID is not set}"
          
          # Locate the .app inside the archive robustly
          ARCHIVE_ROOT=$(find "$HOME/Library/Developer/Xcode/Archives" -name "App-*.xcarchive" -type d | sort -r | head -1)
          if [ -z "$ARCHIVE_ROOT" ] || [ ! -d "$ARCHIVE_ROOT" ]; then
            echo "ERROR: Archive not found"
            exit 1
          fi
          
          APP_DIR="$ARCHIVE_ROOT/Products/Applications"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          if [ -z "$APP_PATH" ] || [ ! -d "$APP_PATH" ]; then
            echo "ERROR: .app not found inside archive at: $APP_DIR"
            exit 1
          fi
          echo "Verifying archive at: $APP_PATH"
          
          # 1) Embedded provisioning profile must exist
          if [ ! -f "$APP_PATH/embedded.mobileprovision" ]; then
            echo "ERROR: embedded.mobileprovision is missing inside the archived app."
            echo "Ensure the archive step embeds the profile (we copy it during archive)."
            exit 1
          fi
          
          # 2) Team in embedded profile must match TEAM_ID
          PROFILE_PLIST=$(/usr/bin/security cms -D -i "$APP_PATH/embedded.mobileprovision")
          PROFILE_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          echo "Archive embedded profile TeamID: $PROFILE_TEAM"
          if [ "$PROFILE_TEAM" != "$TEAM_ID" ]; then
            echo "ERROR: TeamID mismatch. Archive has $PROFILE_TEAM but expected $TEAM_ID."
            exit 1
          fi
          
          # 3) App is signed (no re-sign expected at export)
          codesign -vv "$APP_PATH" && echo "codesign: OK"
          codesign -d --entitlements :- "$APP_PATH" >/dev/null 2>&1 || {
            echo "ERROR: Could not read entitlements from archived app (signature issue)."
            exit 1
          }
          echo "Archive signing verified."
      
      - name: Export IPA
        script: |
          set -euo pipefail
          cd ios/App
          
          : "${TEAM_ID:?TEAM_ID is not set}"
          : "${BUNDLE_ID:?BUNDLE_ID is not set}"
          : "${PROFILE_NAME:?PROFILE_NAME is not set (ensure profile install step exported it)}"
          : "${PROFILE_UUID:?PROFILE_UUID is not set (ensure profile install step exported it)}"
          
          # Find the most recent archive (date-based format)
          ARCHIVE_PATH=$(find "$HOME/Library/Developer/Xcode/Archives" -name "App-*.xcarchive" -type d | sort -r | head -1)
          if [ -z "$ARCHIVE_PATH" ] || [ ! -d "$ARCHIVE_PATH" ]; then
            echo "ERROR: Archive not found. Expected in $HOME/Library/Developer/Xcode/Archives"
            exit 1
          fi
          echo "Using archive: $ARCHIVE_PATH"
          
          # Determine the .app inside the archive robustly
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          if [ -z "$APP_PATH" ] || [ ! -d "$APP_PATH" ]; then
            echo "ERROR: .app not found inside archive at: $APP_DIR"
            exit 1
          fi
          
          # Embed provisioning profile (harmless if already present)
          PROFILE_SRC="$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision"
          if [ -f "$PROFILE_SRC" ]; then
            echo "Embedding provisioning profile into archived app: $APP_PATH"
            cp -f "$PROFILE_SRC" "$APP_PATH/embedded.mobileprovision"
          else
            echo "WARN: $PROFILE_SRC not found; continuing."
          fi
          
          # Verify ExportOptions.plist template exists
          if [ ! -f "ExportOptions.plist" ]; then
            echo "ERROR: ExportOptions.plist template not found"
            echo "This file should be committed to git at ios/App/ExportOptions.plist"
            exit 1
          fi
          
          echo "=== Exporting IPA ==="
          
          # Start from template
          cp ExportOptions.plist ExportOptions.processed.plist
          
          # Modern method
          /usr/libexec/PlistBuddy -c "Delete :method" ExportOptions.processed.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :method string app-store-connect" ExportOptions.processed.plist
          
          # Force AUTOMATIC at export so Xcode packages without re-signing
          /usr/libexec/PlistBuddy -c "Delete :signingStyle" ExportOptions.processed.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :signingStyle string automatic" ExportOptions.processed.plist
          
          # CRITICAL: ensure NO provisioningProfiles at export (prevents framework mapping)
          /usr/libexec/PlistBuddy -c "Delete :provisioningProfiles" ExportOptions.processed.plist 2>/dev/null || true
          
          # Remove teamID so exporter doesn't infer re-sign context
          /usr/libexec/PlistBuddy -c "Delete :teamID" ExportOptions.processed.plist 2>/dev/null || true
          
          # Safe defaults
          /usr/libexec/PlistBuddy -c "Delete :compileBitcode" ExportOptions.processed.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :compileBitcode bool false" ExportOptions.processed.plist
          /usr/libexec/PlistBuddy -c "Delete :stripSwiftSymbols" ExportOptions.processed.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :stripSwiftSymbols bool true" ExportOptions.processed.plist
          /usr/libexec/PlistBuddy -c "Delete :destination" ExportOptions.processed.plist 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :destination string export" ExportOptions.processed.plist
          
          # Assert we truly removed any signing hints that trigger re-sign
          if /usr/libexec/PlistBuddy -c "Print :provisioningProfiles" ExportOptions.processed.plist >/dev/null 2>&1; then
            echo "ERROR: provisioningProfiles still present in ExportOptions.processed.plist"
            exit 1
          fi
          if /usr/libexec/PlistBuddy -c "Print :teamID" ExportOptions.processed.plist >/dev/null 2>&1; then
            echo "ERROR: teamID still present in ExportOptions.processed.plist"
            exit 1
          fi
          
          EXPORT_PATH="$CM_BUILD_DIR/ipa"
          mkdir -p "$EXPORT_PATH"
          
          echo "Export options file: ExportOptions.processed.plist"
          echo "Export options content:"
          cat ExportOptions.processed.plist
          echo ""
          
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist ExportOptions.processed.plist \
            -allowProvisioningUpdates \
            2>&1 | tee /tmp/export.log || {
            echo ""
            echo "=== IPA EXPORT FAILED ==="
            echo ""
            echo "Error details from export log:"
            tail -50 /tmp/export.log
            echo ""
            exit 1
          }
          
          IPA_FILE=$(find "$EXPORT_PATH" -name "*.ipa" -type f | head -1 || true)
          [ -n "$IPA_FILE" ] || { 
            echo "ERROR: IPA file not found after export"
            tail -50 /tmp/export.log || true
            exit 1
          }
          
          echo "✓ IPA exported successfully: $IPA_FILE"
          ls -lh "$IPA_FILE"
          
          cd ../..
      
      - name: Upload to TestFlight (Optional)
        script: |
          set -euo pipefail
          
          IPA_FILE=$(find "$CM_BUILD_DIR/ipa" -name "*.ipa" -type f | head -1 || true)
          
          if [ -z "$IPA_FILE" ]; then
            echo "ERROR: IPA file not found in $CM_BUILD_DIR/ipa"
            echo "IPA export must have failed in previous step"
            exit 1
          fi
          
          echo "=== TestFlight Upload (Optional) ==="
          
          # Check if App Store Connect API credentials are available
          if [ -z "${ASC_KEY_ID:-}" ] || [ -z "${ASC_ISSUER_ID:-}" ]; then
            echo "⚠ App Store Connect API credentials not found"
            echo "  ASC_KEY_ID: ${ASC_KEY_ID:-not set}"
            echo "  ASC_ISSUER_ID: ${ASC_ISSUER_ID:-not set}"
            echo ""
            echo "Skipping TestFlight upload."
            echo "The IPA file is available as a Codemagic artifact for manual upload."
            echo ""
            echo "To enable automatic TestFlight upload:"
            echo "1. Create an App Store Connect API key in Apple Developer Portal"
            echo "2. Add ASC_KEY_ID and ASC_ISSUER_ID to Codemagic environment variables"
            echo "3. Or set up the apple_credentials group in Codemagic"
            echo ""
            echo "IPA file location: $IPA_FILE"
            exit 0
          fi
          
          echo "Uploading IPA to TestFlight..."
          echo "IPA: $IPA_FILE"
          echo "Key ID: $ASC_KEY_ID"
          echo "Issuer ID: $ASC_ISSUER_ID"
          
          xcrun altool --upload-app \
            --type ios \
            --file "$IPA_FILE" \
            --apiKey "$ASC_KEY_ID" \
            --apiIssuer "$ASC_ISSUER_ID" \
            2>&1 | tee /tmp/upload.log || {
            echo ""
            echo "⚠ TestFlight upload failed"
            echo ""
            echo "Error details:"
            tail -20 /tmp/upload.log
            echo ""
            echo "The IPA file is still available as a Codemagic artifact."
            echo "You can upload it manually to App Store Connect:"
            echo "1. Download the IPA from Codemagic artifacts"
            echo "2. Go to https://appstoreconnect.apple.com"
            echo "3. Navigate to your app → TestFlight"
            echo "4. Upload the IPA manually"
            echo ""
            exit 0
          }
          
          echo "✓ IPA uploaded to TestFlight successfully"
          echo "Check App Store Connect for processing status"
    
    artifacts:
      - build/ipa/*.ipa
      - build/**/*.xcarchive
      - ios/App/ExportOptions.processed.plist
    
    publishing:
      email:
        recipients:
          - robbyaw@icloud.com
        notify:
          success: true
          failure: true
