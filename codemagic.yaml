workflows:
  ios-workflow:
    name: iOS Workflow - Clean Start
    max_build_duration: 120
    instance_type: mac_mini_m1
    environment:
      vars:
        APP_ID: app.randomaita.final
        XCODE_WORKSPACE: "ios/App/App.xcworkspace"
        XCODE_SCHEME: "App"
        BUNDLE_ID: app.randomaita.final
        TEAM_ID: US86BZ3GH5
        # App Store Connect API credentials for TestFlight upload via iTMSTransporter
        # Set these in Codemagic UI: Teams → Environment variables
        # ASC_KEY_ID: Your App Store Connect API Key ID (e.g., ABCDE12345) - REQUIRED
        # ASC_ISSUER_ID: Your Issuer ID (UUID from App Store Connect) - REQUIRED
        # Provide ONE of the following for the .p8 private key:
        #   - ASC_API_KEY_P8_PATH: Secure file path (if uploaded as Secure file in Codemagic)
        #   - ASC_API_KEY_P8: Raw .p8 file contents (paste entire file, mark as Secret) - RECOMMENDED
        #   - ASC_API_KEY_P8_BASE64: Base64 encoded .p8 file contents (mark as Secret)
        # Recommended: Use ASC_API_KEY_P8 (paste raw .p8 contents as a Secret variable)
      groups:
        - ios_signing  # iOS certificate and profile secrets (CERT_P12_BASE64, P12_PASSWORD, MOBILEPROVISION_BASE64, PROFILE_NAME)
    scripts:
      - name: Install Node.js dependencies
        script: |
          npm ci
      
      - name: Sync Capacitor
        script: |
          npx cap sync ios
      
      - name: Clear DerivedData
        script: |
          rm -rf ~/Library/Developer/Xcode/DerivedData/*
      
      - name: Install Certificate and Provisioning Profile
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          : "${CERT_P12_BASE64:?missing CERT_P12_BASE64}"
          : "${MOBILEPROVISION_BASE64:?missing MOBILEPROVISION_BASE64}"
          # Optional: PROFILE_NAME; Required now: P12_PASSWORD (non-empty)
          
          KEYCHAIN=build.keychain
          
          b64_decode() { if base64 --help >/dev/null 2>&1; then base64 --decode; else base64 -D; fi; }
          strip_wrap_quotes() { sed 's/^"//; s/"$//'; }
          trim_pw() { tr -d '\r' | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//'; }
          
          # Normalize password
          P12_PASSWORD_RAW="${P12_PASSWORD-}"
          P12_PASSWORD_CLEAN="$(printf %s "$P12_PASSWORD_RAW" | strip_wrap_quotes | trim_pw)"
          if [ -z "$P12_PASSWORD_CLEAN" ]; then
            echo "ERROR: P12_PASSWORD is required for this certificate."
            exit 1
          fi
          
          # Keychain
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 7200 "$KEYCHAIN"
          
          # Decode inputs
          printf %s "$CERT_P12_BASE64"        | strip_wrap_quotes | b64_decode > /tmp/cert.p12
          printf %s "$MOBILEPROVISION_BASE64" | strip_wrap_quotes | b64_decode > /tmp/profile.mobileprovision
          
          # Hard hash assertion to prevent stale secrets
          EXPECTED_P12_SHA256="a301c8c8988c2c2cbc2ef72ab2cfb96b4e5deae6ae37725b0176dcb086b158f2"
          ACTUAL_SHA256="$(shasum -a 256 /tmp/cert.p12 2>/dev/null | awk '{print $1}' || echo unknown)"
          
          echo "=== Certificate Debug Info ==="
          echo "P12 file size: $(stat -f%z /tmp/cert.p12 2>/dev/null || stat -c%s /tmp/cert.p12 2>/dev/null || wc -c < /tmp/cert.p12) bytes"
          echo "ASSERT p12 SHA256: $ACTUAL_SHA256"
          echo "P12_PASSWORD length: ${#P12_PASSWORD_CLEAN}"
          
          # Case-insensitive comparison (convert both to lowercase)
          if [ "$(echo "$ACTUAL_SHA256" | tr '[:upper:]' '[:lower:]')" != "$(echo "$EXPECTED_P12_SHA256" | tr '[:upper:]' '[:lower:]')" ]; then
            echo "ERROR: Codemagic is not using the expected certificate. Update CERT_P12_BASE64."
            echo "Expected: $EXPECTED_P12_SHA256"
            echo "Actual:   $ACTUAL_SHA256"
            exit 1
          fi
          
          # Pre-verify with OpenSSL using the SAME password
          if ! openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD_CLEAN}" -nokeys -info >/dev/null 2>&1 \
             && ! openssl pkcs12 -legacy -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD_CLEAN}" -nokeys -info >/dev/null 2>&1; then
            echo "ERROR: OpenSSL cannot open p12 with the provided password (wrong password or corrupt p12)."
            exit 1
          fi
          echo "OpenSSL check: p12 verified WITH password."
          
          # Import (WITH password)
          echo "Import path: WITH password"
          security import /tmp/cert.p12 -k "$KEYCHAIN" -f pkcs12 -P "$P12_PASSWORD_CLEAN" \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          
          # Allow tools to access the key non-interactively
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"
          
          # Install provisioning profile
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROFILE_PLIST=$(/usr/bin/security cms -D -i /tmp/profile.mobileprovision)
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST")
          PROFILE_NAME_SAFE=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST")
          : "${PROFILE_UUID:?Failed to parse profile UUID}"
          cp /tmp/profile.mobileprovision "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision"
          
          # === BEGIN: Provisioning profile facts (export for later steps) ===
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST")
          TEAM_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          APP_ID_FULL=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          
          # Derive bundle id from application-identifier (TEAMID.bundleid)
          BUNDLE_ID="${APP_ID_FULL#${TEAM_ID}.}"
          
          echo "Profile Name: $PROFILE_NAME"
          echo "Profile UUID: $PROFILE_UUID"
          echo "Team ID     : $TEAM_ID"
          echo "App ID Full : $APP_ID_FULL"
          echo "Bundle ID   : $BUNDLE_ID"
          
          # Export to Codemagic env for subsequent steps
          echo "PROFILE_UUID=$PROFILE_UUID" >> "$CM_ENV"
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$CM_ENV"
          echo "TEAM_ID=$TEAM_ID"           >> "$CM_ENV"
          echo "BUNDLE_ID=$BUNDLE_ID"       >> "$CM_ENV"
          # === END: Provisioning profile facts ===
          
          echo "${PROFILE_NAME:-${PROFILE_NAME_SAFE:-}}" > /tmp/profile_name.txt
          echo "$PROFILE_UUID" > /tmp/profile_uuid.txt
          
          echo "✓ Certificate imported and profile installed ($PROFILE_UUID)"
      
      - name: Clean Pods Deterministically
        script: |
          set -euo pipefail
          cd ios/App
          pod repo update
          pod deintegrate || true
          rm -rf Pods Podfile.lock
          pod install --repo-update
          cd ../..
      
      - name: Verify Signing Configuration
        script: |
          set -euo pipefail
          cd ios/App
          
          echo "=== App target (Release) ==="
          xcodebuild -showBuildSettings -workspace App.xcworkspace -scheme App -configuration Release 2>/dev/null \
           | grep -E "PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|PROVISIONING_PROFILE_SPECIFIER" | sed 's/^[[:space:]]*//'
          
          echo ""
          echo "=== Pods-App target (Release) — expect CODE_SIGNING_ALLOWED = NO ==="
          xcodebuild -showBuildSettings -project Pods/Pods.xcodeproj -target Pods-App -configuration Release 2>/dev/null \
           | grep -E "CODE_SIGNING_ALLOWED|CODE_SIGN_STYLE|PROVISIONING_PROFILE" | sed 's/^[[:space:]]*//' || echo "Pods-App target not found (this is OK if pods not installed yet)"
          
          cd ../..
      
      - name: Auto-bump Build Number
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          # Use a monotonically increasing build number. Prefer CI run/build number if available.
          BUILD_NUM="${CM_BUILD_ID:-$(date +%Y%m%d%H%M)}"
          
          # Point to the app's Info.plist inside the iOS project
          PLIST="ios/App/App/Info.plist"
          
          # Verify plist exists
          if [ ! -f "$PLIST" ]; then
            echo "ERROR: Info.plist not found at $PLIST"
            exit 1
          fi
          
          # Get current build number for logging
          CURRENT_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$PLIST" 2>/dev/null || echo "(not set)")
          echo "Current CFBundleVersion: $CURRENT_BUILD"
          
          # Update CFBundleVersion (build) only. Do NOT touch CFBundleShortVersionString (marketing version).
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUM" "$PLIST" \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $BUILD_NUM" "$PLIST"
          
          # Verify the update
          VERIFIED_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$PLIST")
          if [ "$VERIFIED_BUILD" != "$BUILD_NUM" ]; then
            echo "ERROR: Failed to update CFBundleVersion. Expected $BUILD_NUM, got $VERIFIED_BUILD"
            exit 1
          fi
          
          echo "✓ Set CFBundleVersion to $BUILD_NUM (was: $CURRENT_BUILD)"
      
      - name: Build Archive
        script: |
          set -euo pipefail
          cd ios/App
          
          : "${TEAM_ID:?TEAM_ID is not set}"
          : "${BUNDLE_ID:?BUNDLE_ID is not set}"
          : "${PROFILE_UUID:?PROFILE_UUID is not set}"
          
          KEYCHAIN=build.keychain
          
          echo "Using Team: $TEAM_ID"
          echo "Using Bundle ID: $BUNDLE_ID"
          echo "Using Profile UUID: $PROFILE_UUID"
          
          ARCHIVE_PATH="$HOME/Library/Developer/Xcode/Archives/$(date +%Y-%m-%d)/App-$(date +%H%M).xcarchive"
          mkdir -p "$(dirname "$ARCHIVE_PATH")"
          
          if command -v xcpretty >/dev/null 2>&1; then
            xcodebuild -workspace App.xcworkspace \
              -scheme App \
              -configuration Release \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              CODE_SIGN_STYLE=Manual \
              DEVELOPMENT_TEAM="$TEAM_ID" \
              PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              PROVISIONING_PROFILE_SPECIFIER= \
              OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN" \
              archive 2>&1 | xcpretty && exit ${PIPESTATUS[0]} || {
              echo ""
              echo "=== ARCHIVE BUILD FAILED ==="
              exit 1
            }
          else
            xcodebuild -workspace App.xcworkspace \
              -scheme App \
              -configuration Release \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              CODE_SIGN_STYLE=Manual \
              DEVELOPMENT_TEAM="$TEAM_ID" \
              PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
              PROVISIONING_PROFILE="$PROFILE_UUID" \
              PROVISIONING_PROFILE_SPECIFIER= \
              OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN" \
              archive 2>&1 | tee /tmp/archive_build.log || {
              echo ""
              echo "=== ARCHIVE BUILD FAILED ==="
              echo ""
              echo "Error details from build log:"
              tail -50 /tmp/archive_build.log
              echo ""
              exit 1
            }
          fi
          
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "ERROR: Archive was not created at $ARCHIVE_PATH"
            exit 1
          fi
          
          echo "✓ Archive created successfully at $ARCHIVE_PATH"
          
          # Export ARCHIVE_PATH for subsequent steps
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$CM_ENV"
          
          cd ../..
      
      - name: Verify Archive Signing
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          : "${TEAM_ID:?TEAM_ID is not set}"
          
          # Prefer ARCHIVE_PATH exported by the archive step; fall back to latest
          if [ -n "${ARCHIVE_PATH-}" ] && [ -d "$ARCHIVE_PATH" ]; then
            ARCHIVE_ROOT="$ARCHIVE_PATH"
          else
            ARCHIVE_ROOT="$(find "$HOME/Library/Developer/Xcode/Archives" -type d -name "*.xcarchive" -print0 \
              | xargs -0 ls -1td \
              | head -1 || true)"
          fi
          
          if [ -z "${ARCHIVE_ROOT:-}" ] || [ ! -d "$ARCHIVE_ROOT" ]; then
            echo "ERROR: Archive not found under $HOME/Library/Developer/Xcode/Archives"
            exit 1
          fi
          
          echo "Using archive: $ARCHIVE_ROOT"
          
          APP_DIR="$ARCHIVE_ROOT/Products/Applications"
          
          # Robustly locate the first .app (handles any product name)
          APP_PATH="$(find "$APP_DIR" -maxdepth 1 -type d -name "*.app" -print -quit || true)"
          
          if [ -z "$APP_PATH" ] || [ ! -d "$APP_PATH" ]; then
            echo "ERROR: No .app found inside: $APP_DIR"
            echo "Contents of Applications directory:"
            ls -la "$APP_DIR" || true
            echo "Archive tree (one level):"
            find "$ARCHIVE_ROOT/Products" -maxdepth 2 -print
            exit 1
          fi
          
          echo "Verifying archive at: $APP_PATH"
          
          # 1) Embedded provisioning profile must exist
          if [ ! -f "$APP_PATH/embedded.mobileprovision" ]; then
            echo "ERROR: embedded.mobileprovision is missing inside the archived app."
            echo "Ensure the archive step embeds the profile (copy $PROFILE_UUID.mobileprovision before export)."
            exit 1
          fi
          
          # 2) Team in embedded profile must match TEAM_ID
          PROFILE_PLIST=$(/usr/bin/security cms -D -i "$APP_PATH/embedded.mobileprovision")
          PROFILE_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          echo "Archive embedded profile TeamID: $PROFILE_TEAM"
          if [ "$PROFILE_TEAM" != "$TEAM_ID" ]; then
            echo "ERROR: TeamID mismatch. Archive has $PROFILE_TEAM but expected $TEAM_ID."
            exit 1
          fi
          
          # 3) App is signed (no re-sign expected at export)
          codesign -vv "$APP_PATH" && echo "codesign: OK"
          codesign -d --entitlements :- "$APP_PATH" >/dev/null 2>&1 || {
            echo "ERROR: Could not read entitlements from archived app (signature issue)."
            exit 1
          }
          echo "Archive signing verified."
      
      - name: Export IPA
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          # Prefer ARCHIVE_PATH from previous step; fall back to latest
          if [ -n "${ARCHIVE_PATH-}" ] && [ -d "$ARCHIVE_PATH" ]; then
            ARCHIVE_ROOT="$ARCHIVE_PATH"
          else
            ARCHIVE_ROOT="$(find "$HOME/Library/Developer/Xcode/Archives" -type d -name "*.xcarchive" -print0 \
              | xargs -0 ls -1td | head -1)"
          fi
          echo "Using archive: $ARCHIVE_ROOT"
          
          APP_DIR="$ARCHIVE_ROOT/Products/Applications"
          APP_PATH="$(find "$APP_DIR" -maxdepth 1 -type d -name '*.app' -print -quit)"
          [ -n "$APP_PATH" ] && [ -d "$APP_PATH" ] || { echo "ERROR: .app not found in $APP_DIR"; exit 1; }
          echo "Found app: $APP_PATH"
          
          # Ensure embedded profile is present (harmless if already there)
          if [ -n "${PROFILE_UUID-}" ] && [ -f "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision" ]; then
            echo "Embedding provisioning profile"
            cp -f "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision" "$APP_PATH/embedded.mobileprovision"
          fi
          
          # Sanity: app must be signed
          codesign -vv "$APP_PATH" && echo "codesign: OK"
          
          # Build IPA structure
          EXPORT_PATH="$CM_BUILD_DIR/ipa"
          PAYLOAD_DIR="$EXPORT_PATH/Payload"
          rm -rf "$EXPORT_PATH"
          mkdir -p "$PAYLOAD_DIR"
          
          # Copy the .app
          cp -R "$APP_PATH" "$PAYLOAD_DIR/"
          
          # Optional: include SwiftSupport if present (non-fatal if missing)
          SWIFT_DIR_SRC="$ARCHIVE_ROOT/SwiftSupport"
          if [ -d "$SWIFT_DIR_SRC" ]; then
            echo "Including SwiftSupport"
            cp -R "$SWIFT_DIR_SRC" "$EXPORT_PATH/SwiftSupport"
          fi
          
          # Optional: include Symbols/dSYM (nice to have)
          DSYM_DIR="$ARCHIVE_ROOT/dSYMs"
          if [ -d "$DSYM_DIR" ]; then
            echo "Including dSYMs"
            cp -R "$DSYM_DIR" "$EXPORT_PATH/dSYMs"
          fi
          
          # Zip IPA
          IPA_FILE="$EXPORT_PATH/App.ipa"
          (
            cd "$EXPORT_PATH"
            /usr/bin/zip -qry "$IPA_FILE" Payload SwiftSupport 2>/dev/null || /usr/bin/zip -qry "$IPA_FILE" Payload
          )
          
          [ -f "$IPA_FILE" ] || { echo "ERROR: IPA not created"; exit 1; }
          echo "✓ IPA exported successfully: $IPA_FILE"
          ls -lh "$IPA_FILE"
      
      - name: Publish to TestFlight
        script: |
          #!/usr/bin/env bash
          set -euo pipefail
          
          IPA_FILE="$CM_BUILD_DIR/ipa/App.ipa"
          [ -f "$IPA_FILE" ] || { echo "ERROR: IPA not found at $IPA_FILE"; exit 1; }
          
          : "${ASC_KEY_ID:?ASC_KEY_ID missing}"
          : "${ASC_ISSUER_ID:?ASC_ISSUER_ID missing}"
          
          # Resolve the .p8 private key via one of: PATH, raw, or base64
          TMP_KEY_DIR="$HOME/.private_keys"
          mkdir -p "$TMP_KEY_DIR"
          DEST_KEY="$TMP_KEY_DIR/AuthKey_${ASC_KEY_ID}.p8"
          
          if [ -n "${ASC_API_KEY_P8_PATH-}" ] && [ -f "$ASC_API_KEY_P8_PATH" ]; then
            cp -f "$ASC_API_KEY_P8_PATH" "$DEST_KEY"
          elif [ -n "${ASC_API_KEY_P8-}" ]; then
            printf "%s" "$ASC_API_KEY_P8" > "$DEST_KEY"
          elif [ -n "${ASC_API_KEY_P8_BASE64-}" ]; then
            printf "%s" "$ASC_API_KEY_P8_BASE64" | base64 --decode > "$DEST_KEY" || \
            printf "%s" "$ASC_API_KEY_P8_BASE64" | base64 -D > "$DEST_KEY"
          else
            echo "ERROR: Provide one of ASC_API_KEY_P8_PATH, ASC_API_KEY_P8, ASC_API_KEY_P8_BASE64"
            exit 1
          fi
          chmod 600 "$DEST_KEY"
          
          echo "Using key file: $DEST_KEY"
          echo "Key file size: $(stat -f%z "$DEST_KEY" 2>/dev/null || stat -c%s "$DEST_KEY" 2>/dev/null || wc -c < "$DEST_KEY") bytes"
          
          # Pre-flight bundle/version (useful for logs)
          TMP_DIR="$(mktemp -d)"
          unzip -qq "$IPA_FILE" -d "$TMP_DIR"
          APP_PLIST="$(/bin/ls -1 "$TMP_DIR/Payload/"*.app/Info.plist | head -1)"
          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$APP_PLIST" 2>/dev/null || echo "(unknown)")
          VER=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$APP_PLIST" 2>/dev/null || echo "(unknown)")
          BUILD=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$APP_PLIST" 2>/dev/null || echo "(unknown)")
          echo "IPA identifiers → Bundle: $BUNDLE_ID  Version: $VER  Build: $BUILD"
          echo "Preflight: App record must exist in App Store Connect for bundle: $BUNDLE_ID"
          rm -rf "$TMP_DIR"
          echo ""
          
          # ---- Try iTMSTransporter (multiple real locations) ----
          export LC_ALL=en_US.UTF-8
          export LANG=en_US.UTF-8
          export JAVA_TOOL_OPTIONS="-Djava.awt.headless=true"
          
          # Try known Xcode paths first (ContentDeliveryServices.framework in modern Xcode)
          TRANSPORTER_BIN="$(
            /usr/bin/find /Applications -type f -perm -111 2>/dev/null \
              \( -path "*/Contents/SharedFrameworks/ContentDeliveryServices.framework*/itms/bin/iTMSTransporter" \
                 -o -path "*/Application Loader.app/Contents/itms/bin/iTMSTransporter" \
                 -o -path "*/Transporter.app/Contents/itms/bin/iTMSTransporter" \
                 -o -path "*/itms/bin/iTMSTransporter" \
                 -o -name "iTMSTransporter" \) \
            | head -1
          )"
          
          if [ -n "$TRANSPORTER_BIN" ] && [ -x "$TRANSPORTER_BIN" ]; then
            echo "Using Transporter binary: $TRANSPORTER_BIN"
            set -o pipefail
            "$TRANSPORTER_BIN" \
              -m upload \
              -assetFile "$IPA_FILE" \
              -apiKey "$ASC_KEY_ID" \
              -apiIssuer "$ASC_ISSUER_ID" \
              -v informational \
              -WONoPause true \
              2>&1 | tee /tmp/transporter.log
            
            if grep -Ei "was uploaded successfully" /tmp/transporter.log >/dev/null; then
              echo "✓ Transporter reports success."
              exit 0
            fi
            
            echo "Transporter did not report success. Tail:"
            tail -200 /tmp/transporter.log
            echo "Falling back to Fastlane deliver…"
          else
            echo "iTMSTransporter not found. Using Fastlane deliver fallback…"
          fi
          
          # ---- Fallback: Fastlane deliver with API key JSON (robust on all images) ----
          # Create a temporary App Store Connect API key JSON for fastlane
          API_JSON="$HOME/.private_keys/appstore_api_key.json"
          cat > "$API_JSON" <<JSON
          {
            "key_id": "$ASC_KEY_ID",
            "issuer_id": "$ASC_ISSUER_ID",
            "key": "$(sed 's/$/\\n/' "$DEST_KEY" | tr -d '\n' | sed 's/\\n$//')",
            "in_house": false
          }
          JSON
          
          echo "Using Fastlane deliver fallback with API key JSON at $API_JSON"
          # Prefer deliver (metadata uploader). It can upload binaries with --ipa and api key.
          # Skip metadata/screenshots to just push the build to App Store Connect.
          set -o pipefail
          if command -v bundle >/dev/null 2>&1 && [ -f "Gemfile" ]; then
            bundle exec fastlane deliver \
              --api_key_path "$API_JSON" \
              --ipa "$IPA_FILE" \
              --skip_metadata true \
              --skip_screenshots true \
              --skip_app_version_update true \
              --force 2>&1 | tee /tmp/deliver.log
          else
            fastlane deliver \
              --api_key_path "$API_JSON" \
              --ipa "$IPA_FILE" \
              --skip_metadata true \
              --skip_screenshots true \
              --skip_app_version_update true \
              --force 2>&1 | tee /tmp/deliver.log
          fi
          
          if grep -Ei "Successfully uploaded the new binary to App Store Connect" /tmp/deliver.log >/dev/null; then
            echo "✓ Fastlane deliver reports success."
            exit 0
          fi
          
          echo "Fastlane deliver did not report success. Tail:"
          tail -200 /tmp/deliver.log
          exit 1
    
    artifacts:
      - build/ipa/*.ipa
      - build/**/*.xcarchive
      - ios/App/ExportOptions.processed.plist
    
    publishing:
      email:
        recipients:
          - robbyaw@icloud.com
        notify:
          success: true
          failure: true
