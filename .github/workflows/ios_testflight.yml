name: iOS TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-and-upload:
    runs-on: macos-14
    timeout-minutes: 60

    env:
      WORKSPACE: ios/App/App.xcworkspace
      SCHEME: App
      CONFIGURATION: Release
      ARCHIVE_PATH: ${{ runner.temp }}/App.xcarchive
      IPA_DIR: ${{ runner.temp }}/ipa
      TEAM_ID: ${{ secrets.TEAM_ID }}                 # e.g. US86BZ3GH5
      BUNDLE_ID: ${{ secrets.BUNDLE_ID }}             # e.g. app.randomaita.final
      PROFILE_NAME: ${{ secrets.PROFILE_NAME }}       # e.g. RandomAITAFinal_AppStore_New

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ruby & Fastlane
        run: |
          if ! command -v fastlane >/dev/null 2>&1; then
            sudo gem install fastlane --no-document
          fi

      # --- Nuke any lingering AdMob/Cordova code ---
      - name: Clean AdMob/Cordova traces
        run: |
          # Ensure no stale imports/calls
          sed -i '' '/import GoogleMobileAds/d' ios/App/App/AppDelegate.swift || true
          sed -i '' '/MobileAds\.shared\.start/d' ios/App/App/AppDelegate.swift || true
          
          # Ensure no Cordova helpers referenced in Podfile
          if grep -q "capacitor-cordova-ios-plugins" ios/App/Podfile; then
            echo "ERROR: Remove Cordova lines from Podfile"
            exit 1
          fi
          echo "✓ Cleaned AdMob/Cordova traces"

      # --- Force IPHONEOS_DEPLOYMENT_TARGET=14.0 in the Xcode project ---
      - name: Hard-set iOS deployment target to 14.0
        run: |
          # Brute-force replace any IPHONEOS_DEPLOYMENT_TARGET to 14.0 in project file
          sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [0-9][0-9]*\.[0-9]*/IPHONEOS_DEPLOYMENT_TARGET = 14.0/g' ios/App/App.xcodeproj/project.pbxproj
          echo "✓ Forced IPHONEOS_DEPLOYMENT_TARGET = 14.0 in Xcode project"

      - name: Install CocoaPods (clean + update)
        run: |
          sudo gem install cocoapods --no-document
          cd ios/App
          rm -rf Pods Podfile.lock
          pod deintegrate || true
          pod install --clean-install --verbose --no-repo-update
          cd ../..
          npx cap sync ios

      # --- Install signing material (p12 + provisioning profile) ---
      - name: Create build keychain & import certificate
        shell: bash
        env:
          CERT_P12_BASE64: ${{ secrets.CERT_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN=signing_temp.keychain
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 7200 "$KEYCHAIN"

          # decode p12
          printf %s "$CERT_P12_BASE64" | base64 --decode > /tmp/cert.p12

          # --- PRECHECK: prove password is correct and extract cert+key ---
          if ! openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -info -nokeys >/dev/null 2>&1; then
            echo "ERROR: p12 password is incorrect or file is corrupt (OpenSSL check failed)."
            exit 1
          fi

          # Extract leaf certificate and private key from the P12
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -clcerts -nokeys -out /tmp/dist_cert.cer
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -nocerts -nodes -out /tmp/dist_key.pem

          # Sanity: show subjects (no secrets printed)
          openssl x509 -in /tmp/dist_cert.cer -noout -subject || true

          # --- IMPORT via PEM (avoids PKCS#12 MAC verification issues) ---
          # Import certificate
          security import /tmp/dist_cert.cer -k "$KEYCHAIN" -A -t cert -f x509

          # Import private key (no password on PEM because we used -nodes)
          security import /tmp/dist_key.pem -k "$KEYCHAIN" -A -t priv

          # Allow codesign/xcodebuild to use the key
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"

          # Verify key is usable
          security find-identity -p codesigning "$KEYCHAIN" || true

      - name: Install provisioning profile (system location)
        shell: bash
        env:
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          : "${MOBILEPROVISION_BASE64:?MOBILEPROVISION_BASE64 not set}"

          # Decode to temp
          PROV_TMP="/tmp/profile.mobileprovision"
          printf '%s' "$MOBILEPROVISION_BASE64" | base64 --decode > "$PROV_TMP"

          # Read UUID + Name
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROV_TMP")"
          PROFILE_UUID="$(
            /usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST"
          )"
          PROFILE_NAME="$(
            /usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          # Install into Xcode's expected directory
          DEST_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$DEST_DIR"
          DEST_PATH="$DEST_DIR/$PROFILE_UUID.mobileprovision"
          cp -f "$PROV_TMP" "$DEST_PATH"

          echo "Installed profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Path: $DEST_PATH"

          # Export values for downstream steps (reused by resolve/sign/archive)
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "PROFILE_PATH=$DEST_PATH"
          } >> "$GITHUB_ENV"

      - name: Resolve signing profile UUID + dist identity
        run: |
          set -euo pipefail

          # Use exported values from previous step
          : "${PROFILE_UUID:?PROFILE_UUID not set}"
          : "${PROFILE_NAME:?PROFILE_NAME not set}"

          # Read team from the installed profile
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROFILE_PATH")"
          TEAM_FROM_PROFILE="$(
            /usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          echo "Resolved profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Team: $TEAM_FROM_PROFILE"

          # Guard: team must match
          if [ "$TEAM_FROM_PROFILE" != "$TEAM_ID" ]; then
            echo "ERROR: Provisioning profile team ($TEAM_FROM_PROFILE) does not match TEAM_ID ($TEAM_ID)"
            exit 1
          fi

          # Find a usable Apple Distribution identity inside our temp keychain
          KEYCHAIN_NAME="signing_temp"
          DIST_IDENTITY="$(
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" 2>/dev/null \
              | sed -n 's/.*"\(Apple.*Distribution.*\)".*/\1/p' \
              | head -1
          )"

          if [ -z "${DIST_IDENTITY:-}" ]; then
            echo "ERROR: No 'Apple Distribution' identity found in keychain '$KEYCHAIN_NAME'"
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
            exit 1
          fi

          echo "Selected distribution identity: $DIST_IDENTITY"

          # Export for later steps
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "DIST_IDENTITY=$DIST_IDENTITY"
          } >> "$GITHUB_ENV"

      # --- Build archive (no re-sign at export later) ---
      - name: Bump build number
        run: |
          BN=$(date +%s)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BN" ios/App/App/Info.plist
          echo "Build number -> $BN"

      - name: Detect Xcode scheme (shared)
        run: |
          set -euo pipefail
          SCHEMES_JSON="$(xcodebuild -list -json -workspace ios/App/App.xcworkspace)"
          # Pick a scheme that contains "App" (most Capacitor templates do), otherwise first shared scheme
          SCHEME="$(python3 - <<'PY'
import json,sys,re
j=json.loads(sys.stdin.read())
schemes=j.get("workspace",{}).get("schemes",[])
pref=[s for s in schemes if re.search(r"\bApp\b", s, re.I)]
print((pref or schemes)[0] if schemes else "")
PY
<<<"$SCHEMES_JSON")"
          [ -n "$SCHEME" ] || { echo "No shared schemes found. Make sure your app scheme is shared in Xcode."; exit 1; }
          echo "Using scheme: $SCHEME"
          echo "SCHEME=$SCHEME" >> "$GITHUB_ENV"

      - name: Show build settings (signing)
        run: |
          set -euo pipefail

          echo "=== List schemes (must include 'App') ==="
          xcodebuild -list -workspace ios/App/App.xcworkspace

          echo "=== Show build settings ==="
          xcodebuild -workspace ios/App/App.xcworkspace -scheme "${SCHEME:-App}" -configuration Release -showBuildSettings > /tmp/showbuild.txt

          echo "=== Signing-related from project ==="
          egrep 'PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|CODE_SIGN_IDENTITY|PROVISIONING_PROFILE_SPECIFIER' /tmp/showbuild.txt || true

          echo "=== Expected (secrets) ==="
          echo "TEAM_ID=$TEAM_ID"
          echo "BUNDLE_ID=$BUNDLE_ID"

          # Guard: the target must resolve to our bundle id
          if ! egrep -q "PRODUCT_BUNDLE_IDENTIFIER = $BUNDLE_ID" /tmp/showbuild.txt; then
            echo "ERROR: Project bundle id does not match BUNDLE_ID=$BUNDLE_ID"
            exit 1
          fi

      # --- Sanity build: compile only, no signing ---
      - name: Compile sanity build (no signing)
        run: |
          set -euo pipefail
          xcodebuild -workspace ios/App/App.xcworkspace \
            -scheme App \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO \
            build | tee /tmp/compile.log

          # Show first errors fast if it fails
          if [ "${PIPESTATUS[0]}" -ne 0 ]; then
            echo "=== FIRST 30 'error:' lines ==="
            grep -nE "error:" -m 30 /tmp/compile.log || true
            echo "=== FIRST 10 '❌' lines ==="
            grep -n "❌" -m 10 /tmp/compile.log || true
            echo "=== TAIL 120 lines ==="
            tail -120 /tmp/compile.log || true
            exit 1
          fi
          echo "✓ Sanity build passed (no signing). Proceeding to archive…"

      - name: Build & archive (manual signing, explicit identity)
        run: |
          set -euo pipefail
          : "${SCHEME:?}"
          : "${TEAM_ID:?}"
          : "${BUNDLE_ID:?}"
          : "${PROFILE_UUID:?}"
          : "${DIST_IDENTITY:?}"

          KEYCHAIN_NAME="signing_temp"   # matches your cert-import step
          DERIVED="$HOME/Library/Developer/Xcode/DerivedData"
          rm -rf "$DERIVED" || true

          echo "=== Signing triplet ==="
          echo "DEVELOPMENT_TEAM=$TEAM_ID"
          echo "PRODUCT_BUNDLE_IDENTIFIER=$BUNDLE_ID"
          echo "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_UUID"
          echo "CODE_SIGN_IDENTITY=$DIST_IDENTITY"
          echo "Keychain: $HOME/Library/Keychains/$KEYCHAIN_NAME.keychain-db"

          ARCHIVE_DIR="$HOME/Library/Developer/Xcode/Archives/$(date +%Y-%m-%d)"
          ARCHIVE_PATH="$ARCHIVE_DIR/App-$(date +%H%M).xcarchive"
          mkdir -p "$ARCHIVE_DIR"

          set -o pipefail
          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme App \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath "$ARCHIVE_PATH" \
            archive \
            CODE_SIGNING_ALLOWED=YES CODE_SIGNING_REQUIRED=YES \
            OTHER_CODE_SIGN_FLAGS="--keychain $HOME/Library/Keychains/$KEYCHAIN_NAME.keychain-db" \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
            CODE_SIGN_IDENTITY="$DIST_IDENTITY" \
            SKIP_INSTALL=NO ENABLE_BITCODE=NO

          echo "✓ Archive at: $ARCHIVE_PATH"

          # Export ARCHIVE_PATH to env for the packaging step
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"

      - name: Verify archived product
        run: |
          set -euo pipefail
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          echo "Archive at: $ARCHIVE_PATH"
          ls -la "$APP_DIR"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          [ -d "$APP_PATH" ] || { echo "ERROR: No .app found in $APP_DIR"; exit 1; }
          echo "Found archived app: $APP_PATH"

          # Embed provisioning profile (defensive)
          if [ -f "/tmp/profile.mobileprovision" ]; then
            cp -f "/tmp/profile.mobileprovision" "$APP_PATH/embedded.mobileprovision"
          fi

          echo "=== codesign identities in keychain ==="
          security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
          echo "=== verify signature ==="
          codesign -vv "$APP_PATH" && echo "codesign OK"

      # --- Package IPA manually (no ExportOptions) ---
      - name: Package IPA (no re-sign)
        run: |
          set -euo pipefail
          # Use ARCHIVE_PATH from previous step or fallback
          ARCHIVE_PATH="${ARCHIVE_PATH:-$HOME/Library/Developer/Xcode/Archives/$(date +%Y-%m-%d)/App-$(date +%H%M).xcarchive}"
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          echo "Found app: $APP_PATH"

          # sanity: codesign must be valid
          codesign -vv "$APP_PATH" && echo "codesign OK"

          mkdir -p "$IPA_DIR/Payload"
          cp -R "$APP_PATH" "$IPA_DIR/Payload/"

          # include SwiftSupport if present
          if [ -d "$ARCHIVE_PATH/SwiftSupport" ]; then
            cp -R "$ARCHIVE_PATH/SwiftSupport" "$IPA_DIR/"
          fi

          (cd "$IPA_DIR" && /usr/bin/zip -qry App.ipa Payload SwiftSupport 2>/dev/null || /usr/bin/zip -qry App.ipa Payload)
          echo "IPA at: $IPA_DIR/App.ipa"

      # --- Upload to TestFlight via API key ---
      - name: Upload to TestFlight (API key)
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_API_KEY_P8: ${{ secrets.ASC_API_KEY_P8 }}   # full PEM text incl BEGIN/END, with newlines
        run: |
          set -euo pipefail
          IPA="$IPA_DIR/App.ipa"
          [ -f "$IPA" ] || { echo "IPA missing"; exit 1; }

          # write .p8 from secret
          mkdir -p "$HOME/.private_keys"
          KEY_PATH="$HOME/.private_keys/AuthKey_${ASC_KEY_ID}.p8"
          printf "%s" "$ASC_API_KEY_P8" > "$KEY_PATH"
          chmod 600 "$KEY_PATH"
          echo "Key size: $(stat -f%z "$KEY_PATH") bytes"

          # build API key json for fastlane
          API_JSON="$HOME/.private_keys/appstore_api_key.json"
          awk 'BEGIN{print "{\042key_id\042:\042'${ASC_KEY_ID}'\042,\042issuer_id\042:\042'${ASC_ISSUER_ID}'\042,\042key\042:\042"} {gsub(/\r/,""); printf "%s\\n",$0} END{print "\042,\042in_house\042:false}"}' "$KEY_PATH" > "$API_JSON"

          fastlane deliver \
            --api_key_path "$API_JSON" \
            --ipa "$IPA" \
            --skip_metadata true \
            --skip_screenshots true \
            --skip_app_version_update true \
            --force

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: App.ipa
          path: ${{ runner.temp }}/ipa/App.ipa


