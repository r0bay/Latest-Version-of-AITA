name: iOS TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-and-upload:
    runs-on: macos-14
    timeout-minutes: 60

    env:
      WORKSPACE: ios/App/App.xcworkspace
      SCHEME: App
      CONFIGURATION: Release
      ARCHIVE_PATH: ${{ runner.temp }}/App.xcarchive
      IPA_DIR: ${{ runner.temp }}/ipa
      TEAM_ID: ${{ secrets.TEAM_ID }}                 # e.g. US86BZ3GH5
      BUNDLE_ID: ${{ secrets.BUNDLE_ID }}             # e.g. app.randomaita.final
      PROFILE_NAME: ${{ secrets.PROFILE_NAME }}       # e.g. RandomAITAFinal_AppStore_New

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ruby & Fastlane
        run: |
          if ! command -v fastlane >/dev/null 2>&1; then
            sudo gem install fastlane --no-document
          fi

      # --- Clean iOS native dir and resync from web assets ---
      - name: Clean and sync Capacitor iOS project
        run: |
          rm -rf ios/App/Pods ios/App/Podfile.lock ios/App/App.xcworkspace
          npx cap sync ios
          echo "✓ Cleaned and synced Capacitor iOS project"

      # --- Force iOS 14.0 + Swift/linker settings across the project ---
      - name: Hard-set iOS deployment target and Swift settings
        run: |
          PBXPROJ="ios/App/App.xcodeproj/project.pbxproj"
          
          # iOS Deployment Target to 14.0 everywhere
          sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [0-9][0-9]*\.[0-9]*/IPHONEOS_DEPLOYMENT_TARGET = 14.0/g' "$PBXPROJ"
          
          # Swift toolchain and embedding
          grep -q 'SWIFT_VERSION' "$PBXPROJ" || echo "// SWIFT_VERSION added by CI" >> "$PBXPROJ"
          sed -i '' 's/SWIFT_VERSION = [0-9.]\+/SWIFT_VERSION = 5.10/g' "$PBXPROJ"
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES/g' "$PBXPROJ"
          
          # Runpath search paths (safe defaults)
          sed -i '' 's|LD_RUNPATH_SEARCH_PATHS = .*|LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";|g' "$PBXPROJ" || true
          
          echo "✓ Forced iOS 14.0, Swift 5.10, and linker settings in Xcode project"

      - name: Install CocoaPods (clean install)
        run: |
          sudo gem install cocoapods --no-document
          cd ios/App
          pod install --clean-install --verbose --no-repo-update
          cd ../..

      # --- Force bundle ID in Xcode project ---
      - name: Force bundle ID
        run: |
          BUNDLE_ID="${BUNDLE_ID:-app.randomaita.final}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $BUNDLE_ID" ios/App/App/App-Info.plist 2>/dev/null || true
          echo "✓ Forced bundle ID: $BUNDLE_ID"

      # --- Install signing material (p12 + provisioning profile) ---
      - name: Create build keychain & import certificate
        shell: bash
        env:
          CERT_P12_BASE64: ${{ secrets.CERT_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN=signing_temp.keychain
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 7200 "$KEYCHAIN"

          # decode p12
          printf %s "$CERT_P12_BASE64" | base64 --decode > /tmp/cert.p12

          # --- PRECHECK: prove password is correct and extract cert+key ---
          if ! openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -info -nokeys >/dev/null 2>&1; then
            echo "ERROR: p12 password is incorrect or file is corrupt (OpenSSL check failed)."
            exit 1
          fi

          # Extract leaf certificate and private key from the P12
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -clcerts -nokeys -out /tmp/dist_cert.cer
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -nocerts -nodes -out /tmp/dist_key.pem

          # Sanity: show subjects (no secrets printed)
          openssl x509 -in /tmp/dist_cert.cer -noout -subject || true

          # --- IMPORT via PEM (avoids PKCS#12 MAC verification issues) ---
          # Import certificate
          security import /tmp/dist_cert.cer -k "$KEYCHAIN" -A -t cert -f x509

          # Import private key (no password on PEM because we used -nodes)
          security import /tmp/dist_key.pem -k "$KEYCHAIN" -A -t priv

          # Allow codesign/xcodebuild to use the key
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"

          # Verify key is usable
          security find-identity -p codesigning "$KEYCHAIN" || true
          
          # Export keychain name for later steps
          echo "KEYCHAIN_NAME=signing_temp" >> "$GITHUB_ENV"

      - name: Install provisioning profile (system location)
        shell: bash
        env:
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          : "${MOBILEPROVISION_BASE64:?MOBILEPROVISION_BASE64 not set}"

          # Decode to temp
          PROV_TMP="/tmp/profile.mobileprovision"
          printf '%s' "$MOBILEPROVISION_BASE64" | base64 --decode > "$PROV_TMP"

          # Read UUID + Name
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROV_TMP")"
          PROFILE_UUID="$(
            /usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST"
          )"
          PROFILE_NAME="$(
            /usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          # Install into Xcode's expected directory
          DEST_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$DEST_DIR"
          DEST_PATH="$DEST_DIR/$PROFILE_UUID.mobileprovision"
          cp -f "$PROV_TMP" "$DEST_PATH"

          echo "Installed profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Path: $DEST_PATH"

          # Export values for downstream steps (reused by resolve/sign/archive)
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "PROFILE_PATH=$DEST_PATH"
          } >> "$GITHUB_ENV"

      - name: Resolve signing profile UUID + dist identity
        run: |
          set -euo pipefail

          # Use exported values from previous step
          : "${PROFILE_UUID:?PROFILE_UUID not set}"
          : "${PROFILE_NAME:?PROFILE_NAME not set}"

          # Read team from the installed profile
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROFILE_PATH")"
          TEAM_FROM_PROFILE="$(
            /usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          echo "Resolved profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Team: $TEAM_FROM_PROFILE"

          # Guard: team must match
          if [ "$TEAM_FROM_PROFILE" != "$TEAM_ID" ]; then
            echo "ERROR: Provisioning profile team ($TEAM_FROM_PROFILE) does not match TEAM_ID ($TEAM_ID)"
            exit 1
          fi

          # Find a usable Apple Distribution identity inside our temp keychain
          KEYCHAIN_NAME="signing_temp"
          DIST_IDENTITY="$(
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" 2>/dev/null \
              | sed -n 's/.*"\(Apple.*Distribution.*\)".*/\1/p' \
              | head -1
          )"

          if [ -z "${DIST_IDENTITY:-}" ]; then
            echo "ERROR: No 'Apple Distribution' identity found in keychain '$KEYCHAIN_NAME'"
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
            exit 1
          fi

          echo "Selected distribution identity: $DIST_IDENTITY"

          # Export for later steps
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "DIST_IDENTITY=$DIST_IDENTITY"
          } >> "$GITHUB_ENV"

      # --- Build archive (no re-sign at export later) ---
      - name: Bump build number
        run: |
          BN=$(date +%s)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BN" ios/App/App/Info.plist
          echo "Build number -> $BN"

      - name: Detect Xcode scheme (shared)
        run: |
          set -euo pipefail
          SCHEMES_JSON="$(xcodebuild -list -json -workspace ios/App/App.xcworkspace)"
          # Pick a scheme that contains "App" (most Capacitor templates do), otherwise first shared scheme
          SCHEME="$(python3 - <<'PY'
import json,sys,re
j=json.loads(sys.stdin.read())
schemes=j.get("workspace",{}).get("schemes",[])
pref=[s for s in schemes if re.search(r"\bApp\b", s, re.I)]
print((pref or schemes)[0] if schemes else "")
PY
<<<"$SCHEMES_JSON")"
          [ -n "$SCHEME" ] || { echo "No shared schemes found. Make sure your app scheme is shared in Xcode."; exit 1; }
          echo "Using scheme: $SCHEME"
          echo "SCHEME=$SCHEME" >> "$GITHUB_ENV"

      - name: Show build settings (signing)
        run: |
          set -euo pipefail

          echo "=== List schemes (must include 'App') ==="
          xcodebuild -list -workspace ios/App/App.xcworkspace

          echo "=== Show build settings ==="
          xcodebuild -workspace ios/App/App.xcworkspace -scheme "${SCHEME:-App}" -configuration Release -showBuildSettings > /tmp/showbuild.txt

          echo "=== Signing-related from project ==="
          egrep 'PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|CODE_SIGN_IDENTITY|PROVISIONING_PROFILE_SPECIFIER' /tmp/showbuild.txt || true

          echo "=== Expected (secrets) ==="
          echo "TEAM_ID=$TEAM_ID"
          echo "BUNDLE_ID=$BUNDLE_ID"

          # Guard: the target must resolve to our bundle id
          if ! egrep -q "PRODUCT_BUNDLE_IDENTIFIER = $BUNDLE_ID" /tmp/showbuild.txt; then
            echo "ERROR: Project bundle id does not match BUNDLE_ID=$BUNDLE_ID"
            exit 1
          fi

      # --- Compile sanity build without signing (fast feedback) ---
      - name: Compile sanity build (no signing)
        run: |
          set -euo pipefail
          set -o pipefail
          
          SCHEME=$(
            xcodebuild -workspace ios/App/App.xcworkspace -list -json | \
            /usr/bin/python3 -c 'import sys,json; d=json.load(sys.stdin); print((d.get("workspace",{}).get("schemes") or ["App"])[0])'
          )
          
          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme "$SCHEME" \
            -configuration Release \
            -sdk iphoneos \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO | tee /tmp/compile.log
          
          # If it fails, surface the first errors nicely:
          if [ "${PIPESTATUS[0]}" -ne 0 ]; then
            echo "=== FIRST 30 'error:' lines ==="
            grep -m 30 -nE "error: " /tmp/compile.log || true
            exit 1
          fi
          echo "✓ Sanity build passed (no signing). Proceeding to archive…"

      # --- Resolve distribution identity from the temp keychain ---
      - name: Resolve distribution identity
        run: |
          set -euo pipefail
          KEYCHAIN_NAME="${KEYCHAIN_NAME:-signing_temp}"
          DIST_IDENTITY=$(security find-identity -p codesigning "$HOME/Library/Keychains/$KEYCHAIN_NAME.keychain-db" \
            | awk -F\" '/Apple Distribution/ {print $2; exit}')
          if [ -z "$DIST_IDENTITY" ]; then
            echo "ERROR: Apple Distribution identity not found in keychain $KEYCHAIN_NAME"
            exit 1
          fi
          echo "Using distribution identity: $DIST_IDENTITY"
          echo "DIST_IDENTITY=$DIST_IDENTITY" >> "$GITHUB_ENV"
          
          # Confirm PROFILE_UUID is present (set in your profile-install step)
          if [ -z "${PROFILE_UUID:-}" ]; then
            echo "ERROR: PROFILE_UUID is not set"
            exit 1
          fi

      - name: Build & archive (manual signing, explicit identity)
        run: |
          set -euo pipefail
          : "${TEAM_ID:?}"
          : "${BUNDLE_ID:?}"
          : "${PROFILE_UUID:?}"
          : "${DIST_IDENTITY:?}"

          KEYCHAIN_NAME="${KEYCHAIN_NAME:-signing_temp}"
          
          # Detect scheme
          SCHEME=$(
            xcodebuild -workspace ios/App/App.xcworkspace -list -json | \
            /usr/bin/python3 -c 'import sys,json; d=json.load(sys.stdin); print((d.get("workspace",{}).get("schemes") or ["App"])[0])'
          )

          ARCHIVE_PATH="$RUNNER_TEMP/App.xcarchive"

          set -o pipefail
          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -archivePath "$ARCHIVE_PATH" \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$DIST_IDENTITY" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
            OTHER_CODE_SIGN_FLAGS="--keychain $HOME/Library/Keychains/$KEYCHAIN_NAME.keychain-db" \
            ENABLE_BITCODE=NO \
            SKIP_INSTALL=NO \
            archive | tee /tmp/archive.log

          # Verify the archived .app exists
          APP_PATH="$ARCHIVE_PATH/Products/Applications/$(/bin/ls -1 "$ARCHIVE_PATH/Products/Applications" | head -1)"
          [ -d "$APP_PATH" ] || { echo "ERROR: Archived .app not found"; exit 1; }

          # Embed the same provisioning profile into the archived app (belt & suspenders)
          cp "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision" "$APP_PATH/embedded.mobileprovision"
          codesign -vv "$APP_PATH"

          echo "✓ Archive at: $ARCHIVE_PATH"
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"
          echo "APP_PATH=$APP_PATH" >> "$GITHUB_ENV"

      - name: Verify archived product
        run: |
          set -euo pipefail
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          echo "Archive at: $ARCHIVE_PATH"
          ls -la "$APP_DIR"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          [ -d "$APP_PATH" ] || { echo "ERROR: No .app found in $APP_DIR"; exit 1; }
          echo "Found archived app: $APP_PATH"

          # Embed provisioning profile (defensive)
          if [ -f "/tmp/profile.mobileprovision" ]; then
            cp -f "/tmp/profile.mobileprovision" "$APP_PATH/embedded.mobileprovision"
          fi

          echo "=== codesign identities in keychain ==="
          security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
          echo "=== verify signature ==="
          codesign -vv "$APP_PATH" && echo "codesign OK"

      # --- Manual IPA packaging (no ExportOptions, no re-sign) ---
      - name: Package IPA (no re-sign)
        run: |
          set -euo pipefail
          : "${ARCHIVE_PATH:?ARCHIVE_PATH not set}"
          : "${APP_PATH:?APP_PATH not set}"
          
          IPA_DIR="$RUNNER_TEMP/ipa"
          rm -rf "$IPA_DIR" && mkdir -p "$IPA_DIR/Payload"
          cp -R "$APP_PATH" "$IPA_DIR/Payload/"

          # Optional: include SwiftSupport if you want (safe to skip on modern uploads)
          if [ -d "$ARCHIVE_PATH/SwiftSupport" ]; then
            cp -R "$ARCHIVE_PATH/SwiftSupport" "$IPA_DIR/"
          fi

          cd "$IPA_DIR"
          zip -qry App.ipa Payload SwiftSupport 2>/dev/null || zip -qry App.ipa Payload
          echo "✓ IPA created at: $IPA_DIR/App.ipa"
          echo "IPA_DIR=$IPA_DIR" >> "$GITHUB_ENV"

      # --- Upload to TestFlight (Transporter if present, else Fastlane) ---
      - name: Upload to TestFlight
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_API_KEY_P8: ${{ secrets.ASC_API_KEY_P8 }}
        run: |
          set -euo pipefail
          IPA_FILE="${IPA_DIR}/App.ipa"
          [ -f "$IPA_FILE" ] || { echo "ERROR: IPA missing"; exit 1; }

          # Write .p8 from secret
          mkdir -p "$HOME/.private_keys"
          KEY_PATH="$HOME/.private_keys/AuthKey_${ASC_KEY_ID}.p8"
          printf "%s" "$ASC_API_KEY_P8" > "$KEY_PATH"
          chmod 600 "$KEY_PATH"

          # Prefer Transporter if the binary exists; else fallback to fastlane deliver
          TRANSPORTER=$(/usr/bin/find /Applications -type f -name iTMSTransporter -perm -111 2>/dev/null | head -1)
          if [ -n "$TRANSPORTER" ]; then
            "$TRANSPORTER" -m upload -assetFile "$IPA_FILE" -apiKey "$ASC_KEY_ID" -apiIssuer "$ASC_ISSUER_ID" -WONoPause true -v informational | tee /tmp/transporter.log
            if grep -qi "was uploaded successfully" /tmp/transporter.log; then
              echo "✓ Transporter upload ok"
              exit 0
            fi
            echo "Transporter failed, falling back to fastlane..."
          fi

          # Fastlane fallback (API key JSON created from your .p8 earlier)
          if ! command -v fastlane >/dev/null 2>&1; then
            sudo gem install fastlane --no-document
          fi

          API_JSON="$HOME/.private_keys/appstore_api_key.json"
          awk 'BEGIN{print "{\042key_id\042:\042'${ASC_KEY_ID}'\042,\042issuer_id\042:\042'${ASC_ISSUER_ID}'\042,\042key\042:\042"} {gsub(/\r/,""); printf "%s\\n",$0} END{print "\042,\042in_house\042:false}"}' "$KEY_PATH" > "$API_JSON"
          
          fastlane deliver --api_key_path "$API_JSON" --ipa "$IPA_FILE" --skip_metadata true --skip_screenshots true --skip_app_version_update true --force | tee /tmp/deliver.log
          if grep -qi "Successfully uploaded the new binary" /tmp/deliver.log; then
            echo "✓ Fastlane upload ok"
            exit 0
          fi

          echo "✗ Upload failed"
          tail -200 /tmp/transporter.log /tmp/deliver.log 2>/dev/null || true
          exit 1

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: App.ipa
          path: ${{ runner.temp }}/ipa/App.ipa


