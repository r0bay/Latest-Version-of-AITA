name: iOS TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-and-upload:
    runs-on: macos-14
    timeout-minutes: 60

    env:
      WORKSPACE: ios/App/App.xcworkspace
      SCHEME: App
      CONFIGURATION: Release
      ARCHIVE_PATH: ${{ runner.temp }}/App.xcarchive
      IPA_DIR: ${{ runner.temp }}/ipa
      TEAM_ID: ${{ secrets.TEAM_ID }}                 # e.g. US86BZ3GH5
      BUNDLE_ID: ${{ secrets.BUNDLE_ID }}             # e.g. app.randomaita.final
      PROFILE_NAME: ${{ secrets.PROFILE_NAME }}       # e.g. RandomAITAFinal_AppStore_New

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ruby & Fastlane
        run: |
          if ! command -v fastlane >/dev/null 2>&1; then
            sudo gem install fastlane --no-document
          fi

      # --- Clean & sync Capacitor iOS and install pods (deterministic + prebuild Pods) ---
      - name: Clean & sync Capacitor iOS and install pods (deterministic + prebuild Pods)
        run: |
          set -euo pipefail

          # Start clean
          rm -rf ios/App/Pods ios/App/Podfile.lock ios/App/App.xcworkspace
          rm -rf ~/Library/Developer/Xcode/DerivedData/* || true

          # Ensure node_modules is present (so node_modules/@capacitor/ios exists)
          if [ ! -d node_modules ]; then
            npm ci
          fi

          # Sync Capacitor (copies web assets + regenerates ios/App)
          npx cap sync ios

          # Install CocoaPods (Bundler if Gemfile exists)
          if [ -f Gemfile ]; then
            bundle config set path 'vendor/bundle'
            bundle install --jobs 4
            bundle exec pod install --project-directory=ios/App --repo-update --clean-install --verbose
          else
            pod install --project-directory=ios/App --repo-update --clean-install --verbose
          fi

          # Sanity: list workspace targets/schemes
          xcodebuild -workspace ios/App/App.xcworkspace -list

          # *** CRITICAL: Prebuild Pods first (surfaces headers/modules issues early) ***
          set +e
          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme Pods-App \
            -configuration Release \
            -sdk iphonesimulator \
            -destination "generic/platform=iOS Simulator" \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            ONLY_ACTIVE_ARCH=NO \
            -UseNewBuildSystem=YES | tee /tmp/pods_prebuild.log
          PODS_STATUS=${PIPESTATUS[0]}
          set -e

          echo "=== FIRST 40 'error:' from Pods prebuild ===" || true
          grep -i -n 'error:' /tmp/pods_prebuild.log | head -40 || true

          if [ "$PODS_STATUS" -ne 0 ]; then
            echo "Pods prebuild failed."
            exit $PODS_STATUS
          fi

          echo "✓ Synced Capacitor, installed pods, and prebuilt Pods"

      # --- Ensure shared Xcode scheme "App" exists ---
      - name: Verify shared Xcode scheme
        run: |
          set -euo pipefail
          SCHEME_FILE="ios/App/App.xcodeproj/xcshareddata/xcschemes/App.xcscheme"
          if [ ! -f "$SCHEME_FILE" ]; then
            echo "WARN: Shared scheme not found at $SCHEME_FILE (should be created by workflow step)"
          else
            echo "✓ Shared scheme exists at $SCHEME_FILE"
          fi
          echo "Schemes in workspace:"
          xcodebuild -workspace ios/App/App.xcworkspace -list

      # --- Force iOS 14.0 + Swift/linker settings across the project ---
      - name: Hard-set iOS deployment target and Swift settings
        run: |
          PBXPROJ="ios/App/App.xcodeproj/project.pbxproj"
          
          # iOS Deployment Target to 14.0 everywhere
          sed -i '' 's/IPHONEOS_DEPLOYMENT_TARGET = [0-9][0-9]*\.[0-9]*/IPHONEOS_DEPLOYMENT_TARGET = 14.0/g' "$PBXPROJ"
          
          # Swift toolchain and embedding
          grep -q 'SWIFT_VERSION' "$PBXPROJ" || echo "// SWIFT_VERSION added by CI" >> "$PBXPROJ"
          sed -i '' 's/SWIFT_VERSION = [0-9.]\+/SWIFT_VERSION = 5.10/g' "$PBXPROJ"
          sed -i '' 's/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO/ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES/g' "$PBXPROJ"
          
          # Runpath search paths (safe defaults)
          sed -i '' 's|LD_RUNPATH_SEARCH_PATHS = .*|LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";|g' "$PBXPROJ" || true
          
          echo "✓ Forced iOS 14.0, Swift 5.10, and linker settings in Xcode project"

      # --- Force bundle ID in Xcode project ---
      - name: Force bundle ID
        run: |
          BUNDLE_ID="${BUNDLE_ID:-app.randomaita.final}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $BUNDLE_ID" ios/App/App/App-Info.plist 2>/dev/null || true
          echo "✓ Forced bundle ID: $BUNDLE_ID"

      # --- Install signing material (p12 + provisioning profile) ---
      - name: Create build keychain & import certificate
        shell: bash
        env:
          CERT_P12_BASE64: ${{ secrets.CERT_P12_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN=signing_temp.keychain
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          security set-keychain-settings -lut 7200 "$KEYCHAIN"

          # decode p12
          printf %s "$CERT_P12_BASE64" | base64 --decode > /tmp/cert.p12

          # --- PRECHECK: prove password is correct and extract cert+key ---
          if ! openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -info -nokeys >/dev/null 2>&1; then
            echo "ERROR: p12 password is incorrect or file is corrupt (OpenSSL check failed)."
            exit 1
          fi

          # Extract leaf certificate and private key from the P12
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -clcerts -nokeys -out /tmp/dist_cert.cer
          openssl pkcs12 -in /tmp/cert.p12 -passin "pass:${P12_PASSWORD}" -nocerts -nodes -out /tmp/dist_key.pem

          # Sanity: show subjects (no secrets printed)
          openssl x509 -in /tmp/dist_cert.cer -noout -subject || true

          # --- IMPORT via PEM (avoids PKCS#12 MAC verification issues) ---
          # Import certificate
          security import /tmp/dist_cert.cer -k "$KEYCHAIN" -A -t cert -f x509

          # Import private key (no password on PEM because we used -nodes)
          security import /tmp/dist_key.pem -k "$KEYCHAIN" -A -t priv

          # Allow codesign/xcodebuild to use the key
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"

          # Verify key is usable
          security find-identity -p codesigning "$KEYCHAIN" || true
          
          # Export keychain name for later steps
          echo "KEYCHAIN_NAME=signing_temp" >> "$GITHUB_ENV"

      - name: Install provisioning profile (system location)
        shell: bash
        env:
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          : "${MOBILEPROVISION_BASE64:?MOBILEPROVISION_BASE64 not set}"

          # Decode to temp
          PROV_TMP="/tmp/profile.mobileprovision"
          printf '%s' "$MOBILEPROVISION_BASE64" | base64 --decode > "$PROV_TMP"

          # Read UUID + Name
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROV_TMP")"
          PROFILE_UUID="$(
            /usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST"
          )"
          PROFILE_NAME="$(
            /usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          # Install into Xcode's expected directory
          DEST_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$DEST_DIR"
          DEST_PATH="$DEST_DIR/$PROFILE_UUID.mobileprovision"
          cp -f "$PROV_TMP" "$DEST_PATH"

          echo "Installed profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Path: $DEST_PATH"

          # Export values for downstream steps (reused by resolve/sign/archive)
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "PROFILE_PATH=$DEST_PATH"
          } >> "$GITHUB_ENV"

      - name: Resolve signing profile UUID + dist identity
        run: |
          set -euo pipefail

          # Use exported values from previous step
          : "${PROFILE_UUID:?PROFILE_UUID not set}"
          : "${PROFILE_NAME:?PROFILE_NAME not set}"

          # Read team from the installed profile
          PROFILE_PLIST="$(/usr/bin/security cms -D -i "$PROFILE_PATH")"
          TEAM_FROM_PROFILE="$(
            /usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' /dev/stdin <<<"$PROFILE_PLIST"
          )"

          echo "Resolved profile:"
          echo "  Name: $PROFILE_NAME"
          echo "  UUID: $PROFILE_UUID"
          echo "  Team: $TEAM_FROM_PROFILE"

          # Guard: team must match
          if [ "$TEAM_FROM_PROFILE" != "$TEAM_ID" ]; then
            echo "ERROR: Provisioning profile team ($TEAM_FROM_PROFILE) does not match TEAM_ID ($TEAM_ID)"
            exit 1
          fi

          # Find a usable Apple Distribution identity inside our temp keychain
          KEYCHAIN_NAME="signing_temp"
          DIST_IDENTITY="$(
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" 2>/dev/null \
              | sed -n 's/.*"\(Apple.*Distribution.*\)".*/\1/p' \
              | head -1
          )"

          if [ -z "${DIST_IDENTITY:-}" ]; then
            echo "ERROR: No 'Apple Distribution' identity found in keychain '$KEYCHAIN_NAME'"
            security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
            exit 1
          fi

          echo "Selected distribution identity: $DIST_IDENTITY"

          # Export for later steps
          {
            echo "PROFILE_UUID=$PROFILE_UUID"
            echo "PROFILE_NAME=$PROFILE_NAME"
            echo "DIST_IDENTITY=$DIST_IDENTITY"
          } >> "$GITHUB_ENV"

      # --- Build archive (no re-sign at export later) ---
      - name: Bump build number
        run: |
          BN=$(date +%s)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BN" ios/App/App/Info.plist
          echo "Build number -> $BN"

      - name: Detect Xcode scheme (shared)
        run: |
          set -euo pipefail
          SCHEMES_JSON="$(xcodebuild -list -json -workspace ios/App/App.xcworkspace)"
          # Pick a scheme that contains "App" (most Capacitor templates do), otherwise first shared scheme
          SCHEME="$(python3 - <<'PY'
import json,sys,re
j=json.loads(sys.stdin.read())
schemes=j.get("workspace",{}).get("schemes",[])
pref=[s for s in schemes if re.search(r"\bApp\b", s, re.I)]
print((pref or schemes)[0] if schemes else "")
PY
<<<"$SCHEMES_JSON")"
          [ -n "$SCHEME" ] || { echo "No shared schemes found. Make sure your app scheme is shared in Xcode."; exit 1; }
          echo "Using scheme: $SCHEME"
          echo "SCHEME=$SCHEME" >> "$GITHUB_ENV"

      - name: Show build settings (signing)
        run: |
          set -euo pipefail

          echo "=== List schemes (must include 'App') ==="
          xcodebuild -list -workspace ios/App/App.xcworkspace

          echo "=== Show build settings ==="
          xcodebuild -workspace ios/App/App.xcworkspace -scheme "${SCHEME:-App}" -configuration Release -showBuildSettings > /tmp/showbuild.txt

          echo "=== Signing-related from project ==="
          egrep 'PRODUCT_BUNDLE_IDENTIFIER|DEVELOPMENT_TEAM|CODE_SIGN_STYLE|CODE_SIGN_IDENTITY|PROVISIONING_PROFILE_SPECIFIER' /tmp/showbuild.txt || true

          echo "=== Expected (secrets) ==="
          echo "TEAM_ID=$TEAM_ID"
          echo "BUNDLE_ID=$BUNDLE_ID"

          # Guard: the target must resolve to our bundle id
          if ! egrep -q "PRODUCT_BUNDLE_IDENTIFIER = $BUNDLE_ID" /tmp/showbuild.txt; then
            echo "ERROR: Project bundle id does not match BUNDLE_ID=$BUNDLE_ID"
            exit 1
          fi

      # --- Compile sanity build (no signing, simulator) ---
      - name: Compile sanity build (no signing, simulator)
        shell: bash
        run: |
          set -euo pipefail

          SCHEME_JSON=$(xcodebuild -workspace ios/App/App.xcworkspace -list -json || true)
          SCHEME=$(ruby -e '
            require "json"
            j = JSON.parse(STDIN.read) rescue {}
            s = (j.dig("workspace","schemes") || []).find{|x| x =~ /^App$/i } || (j.dig("workspace","schemes") || []).find{|x| x =~ /App/i }
            puts(s || "App")
          ' <<< "$SCHEME_JSON")
          echo "Using scheme: $SCHEME"

          set +e
          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme "$SCHEME" \
            -configuration Release \
            -sdk iphonesimulator \
            -destination "generic/platform=iOS Simulator" \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_STYLE=Manual \
            SWIFT_VERSION=5.0 \
            IPHONEOS_DEPLOYMENT_TARGET=14.0 \
            ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES \
            ONLY_ACTIVE_ARCH=NO \
            -UseNewBuildSystem=YES \
            clean build | tee /tmp/sanity_build.log
          BUILD_STATUS=${PIPESTATUS[0]}
          set -e

          echo "=== FIRST 30 'error:' lines ===" || true
          grep -i -n 'error:' /tmp/sanity_build.log | head -30 || true
          echo "=== FIRST 10 '❌' lines ===" || true
          grep -n '❌' /tmp/sanity_build.log | head -10 || true
          echo "=== TAIL 120 lines ===" || true
          tail -120 /tmp/sanity_build.log || true

          mkdir -p artifacts && cp /tmp/sanity_build.log artifacts/sanity_build.log

          exit $BUILD_STATUS

      - name: Upload sanity build log
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sanity-build-log
          path: artifacts/sanity_build.log

      # --- Resolve profile UUID + dist identity ---
      - name: Resolve profile UUID + dist identity
        shell: bash
        env:
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION_BASE64 }}
        run: |
          set -euo pipefail
          : "${TEAM_ID:?TEAM_ID missing}"
          : "${MOBILEPROVISION_BASE64:?MOBILEPROVISION_BASE64 missing}"

          printf "%s" "$MOBILEPROVISION_BASE64" | base64 --decode > /tmp/profile.mobileprovision
          PROFILE_PLIST=$(/usr/bin/security cms -D -i /tmp/profile.mobileprovision)
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<<"$PROFILE_PLIST")
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$PROFILE_PLIST")
          PROFILE_APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin <<<"$PROFILE_PLIST")
          PROFILE_TEAM=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' /dev/stdin <<<"$PROFILE_PLIST")

          echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV
          echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV
          echo "Using profile: $PROFILE_NAME ($PROFILE_UUID)"
          echo "Profile app id: $PROFILE_APPID"
          echo "Profile team:   $PROFILE_TEAM"

          if [ "$PROFILE_TEAM" != "$TEAM_ID" ]; then
            echo "ERROR: Profile team $PROFILE_TEAM != TEAM_ID $TEAM_ID"
            exit 1
          fi

          # Find the Apple Distribution identity imported earlier into keychain
          security find-identity -v -p codesigning "$HOME/Library/Keychains/signing_temp.keychain-db" || true
          DIST_ID=$(security find-identity -v -p codesigning "$HOME/Library/Keychains/signing_temp.keychain-db" \
            | awk -F\" '/Apple Distribution/ {print $2; exit}')
          if [ -z "$DIST_ID" ]; then
            echo "ERROR: No 'Apple Distribution' identity found in keychain"
            exit 1
          fi
          echo "DIST_IDENTITY=$DIST_ID" >> $GITHUB_ENV
          echo "Using distribution identity: $DIST_ID"

      # --- Build & archive (manual signing) ---
      - name: Build & archive (manual signing)
        run: |
          set -euo pipefail
          : "${TEAM_ID:?TEAM_ID missing}"
          : "${BUNDLE_ID:?BUNDLE_ID missing}"
          : "${PROFILE_UUID:?PROFILE_UUID missing}"
          : "${DIST_IDENTITY:?DIST_IDENTITY missing}"

          SCHEME="$(xcodebuild -workspace ios/App/App.xcworkspace -list -json \
            | ruby -rjson -e 'j=JSON.parse(STDIN.read); puts (j["workspace"] ? j["workspace"]["schemes"][0] : j["project"]["schemes"][0])')"
          echo "Using scheme: $SCHEME"

          ARCHIVE_PATH="$RUNNER_TEMP/App.xcarchive"

          xcodebuild \
            -workspace ios/App/App.xcworkspace \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$ARCHIVE_PATH" \
            CODE_SIGNING_ALLOWED=YES \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
            CODE_SIGN_IDENTITY="$DIST_IDENTITY" \
            OTHER_CODE_SIGN_FLAGS="--keychain $HOME/Library/Keychains/signing_temp.keychain-db" \
            SWIFT_VERSION=5.0 \
            IPHONEOS_DEPLOYMENT_TARGET=14.0 \
            ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES \
            ONLY_ACTIVE_ARCH=NO \
            -UseNewBuildSystem=YES \
            archive | tee archive_log.txt

          echo "Archive finished: $ARCHIVE_PATH"
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"

          # Verify .app and embed provisioning profile
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          if [ -z "$APP_PATH" ]; then
            echo "ERROR: .app not found in archive"
            ls -la "$APP_DIR" || true
            exit 1
          fi
          echo "Found app: $APP_PATH"
          cp /tmp/profile.mobileprovision "$APP_PATH/embedded.mobileprovision"
          /usr/bin/codesign -vv "$APP_PATH"

      - name: Verify archived product
        run: |
          set -euo pipefail
          APP_DIR="$ARCHIVE_PATH/Products/Applications"
          echo "Archive at: $ARCHIVE_PATH"
          ls -la "$APP_DIR"
          APP_PATH="$(/bin/ls -1 "$APP_DIR"/*.app | head -1)"
          [ -d "$APP_PATH" ] || { echo "ERROR: No .app found in $APP_DIR"; exit 1; }
          echo "Found archived app: $APP_PATH"

          # Embed provisioning profile (defensive)
          if [ -f "/tmp/profile.mobileprovision" ]; then
            cp -f "/tmp/profile.mobileprovision" "$APP_PATH/embedded.mobileprovision"
          fi

          echo "=== codesign identities in keychain ==="
          security find-identity -p codesigning "$KEYCHAIN_NAME.keychain" || true
          echo "=== verify signature ==="
          codesign -vv "$APP_PATH" && echo "codesign OK"

      # --- Manual IPA packaging (no ExportOptions) ---
      - name: Package IPA (no re-sign)
        run: |
          set -euo pipefail
          : "${ARCHIVE_PATH:?ARCHIVE_PATH not set}"
          
          IPA_OUT="$RUNNER_TEMP/ipa"
          mkdir -p "$IPA_OUT"

          APPDIR="$ARCHIVE_PATH/Products/Applications"
          APP_PATH=$(ls -1 "$APPDIR"/*.app | head -1)
          [ -d "$APP_PATH" ] || { echo "No .app to package"; exit 1; }

          PKG_DIR="$RUNNER_TEMP/payload_root"
          rm -rf "$PKG_DIR"
          mkdir -p "$PKG_DIR/Payload"
          cp -R "$APP_PATH" "$PKG_DIR/Payload/"

          # Optional SwiftSupport if present
          if [ -d "$ARCHIVE_PATH/SwiftSupport" ]; then
            cp -R "$ARCHIVE_PATH/SwiftSupport" "$PKG_DIR/"
          fi

          pushd "$PKG_DIR" >/dev/null
          zip -qry "$IPA_OUT/App.ipa" .
          popd >/dev/null

          echo "IPA_FILE=$IPA_OUT/App.ipa" >> "$GITHUB_ENV"
          ls -lh "$IPA_OUT/App.ipa"
          echo "✓ IPA created at: $IPA_OUT/App.ipa"

      # --- Upload to TestFlight (Transporter if present, else Fastlane) ---
      - name: Upload to TestFlight
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          ASC_API_KEY_P8: ${{ secrets.ASC_API_KEY_P8 }}
        run: |
          set -euo pipefail
          : "${IPA_FILE:?IPA_FILE not set}"
          [ -f "$IPA_FILE" ] || { echo "ERROR: IPA missing"; exit 1; }

          # Write .p8 from secret
          mkdir -p "$HOME/.private_keys"
          KEY_PATH="$HOME/.private_keys/AuthKey_${ASC_KEY_ID}.p8"
          printf "%s" "$ASC_API_KEY_P8" > "$KEY_PATH"
          chmod 600 "$KEY_PATH"

          # Prefer Transporter if the binary exists; else fallback to fastlane deliver
          TRANSPORTER=$(/usr/bin/find /Applications -type f -name iTMSTransporter -perm -111 2>/dev/null | head -1)
          if [ -n "$TRANSPORTER" ]; then
            "$TRANSPORTER" -m upload -assetFile "$IPA_FILE" -apiKey "$ASC_KEY_ID" -apiIssuer "$ASC_ISSUER_ID" -WONoPause true -v informational | tee /tmp/transporter.log
            if grep -qi "was uploaded successfully" /tmp/transporter.log; then
              echo "✓ Transporter upload ok"
              exit 0
            fi
            echo "Transporter failed, falling back to fastlane..."
          fi

          # Fastlane fallback (API key JSON created from your .p8 earlier)
          if ! command -v fastlane >/dev/null 2>&1; then
            sudo gem install fastlane --no-document
          fi

          API_JSON="$HOME/.private_keys/appstore_api_key.json"
          awk 'BEGIN{print "{\042key_id\042:\042'${ASC_KEY_ID}'\042,\042issuer_id\042:\042'${ASC_ISSUER_ID}'\042,\042key\042:\042"} {gsub(/\r/,""); printf "%s\\n",$0} END{print "\042,\042in_house\042:false}"}' "$KEY_PATH" > "$API_JSON"
          
          fastlane deliver --api_key_path "$API_JSON" --ipa "$IPA_FILE" --skip_metadata true --skip_screenshots true --skip_app_version_update true --force | tee /tmp/deliver.log
          if grep -qi "Successfully uploaded the new binary" /tmp/deliver.log; then
            echo "✓ Fastlane upload ok"
            exit 0
          fi

          echo "✗ Upload failed"
          tail -200 /tmp/transporter.log /tmp/deliver.log 2>/dev/null || true
          exit 1

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: App.ipa
          path: ${{ runner.temp }}/ipa/App.ipa


